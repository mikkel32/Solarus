from __future__ import annotations

from typing import Any, Iterator, Sequence


class dtype:
    ...


class ndarray:
    shape: tuple[int, ...]
    size: int
    dtype: Any
    ndim: int

    def __iter__(self) -> Iterator[Any]: ...
    def __len__(self) -> int: ...
    def __eq__(self, other: Any) -> Any: ...
    def __ne__(self, other: Any) -> Any: ...
    def __add__(self, other: Any) -> ndarray: ...
    def __radd__(self, other: Any) -> ndarray: ...
    def __sub__(self, other: Any) -> ndarray: ...
    def __rsub__(self, other: Any) -> ndarray: ...
    def __mul__(self, other: Any) -> ndarray: ...
    def __rmul__(self, other: Any) -> ndarray: ...
    def __truediv__(self, other: Any) -> ndarray: ...
    def __rtruediv__(self, other: Any) -> ndarray: ...
    def __neg__(self) -> ndarray: ...
    def __getitem__(self, key: Any) -> Any: ...
    def astype(self, dtype: Any, copy: bool = ..., order: str | None = ..., casting: str = ..., subok: bool = ..., **kwargs: Any) -> ndarray: ...
    def reshape(self, newshape: Sequence[int] | int, *args: Any, **kwargs: Any) -> ndarray: ...
    def max(self, *args: Any, **kwargs: Any) -> Any: ...
    def min(self, *args: Any, **kwargs: Any) -> Any: ...
    def std(self, *args: Any, **kwargs: Any) -> Any: ...
    def sum(self, *args: Any, **kwargs: Any) -> Any: ...
    def mean(self, *args: Any, **kwargs: Any) -> Any: ...
    def clip(self, *args: Any, **kwargs: Any) -> ndarray: ...
    def numpy(self) -> ndarray: ...
    def detach(self) -> Any: ...
    def cpu(self) -> ndarray: ...
    def tolist(self) -> list[Any]: ...
    def item(self, *args: Any, **kwargs: Any) -> Any: ...


float32: dtype
float64: dtype
int64: dtype


def array(obj: Any, dtype: Any = ..., *args: Any, **kwargs: Any) -> ndarray: ...
def asarray(obj: Any, dtype: Any = ..., *args: Any, **kwargs: Any) -> ndarray: ...
def atleast_1d(*arys: Any) -> ndarray: ...
def concatenate(arrays: Sequence[Any], axis: int | None = ..., *args: Any, **kwargs: Any) -> ndarray: ...
def exp(x: Any, *args: Any, **kwargs: Any) -> ndarray: ...
def full(shape: Sequence[int] | int, fill_value: Any, dtype: Any = ..., *args: Any, **kwargs: Any) -> ndarray: ...
def full_like(a: Any, fill_value: Any, dtype: Any = ..., *args: Any, **kwargs: Any) -> ndarray: ...
def isfinite(x: Any, *args: Any, **kwargs: Any) -> Any: ...
def max(a: Any, *args: Any, **kwargs: Any) -> Any: ...
def min(a: Any, *args: Any, **kwargs: Any) -> Any: ...
def pad(array: Any, pad_width: Any, mode: Any = ..., *args: Any, **kwargs: Any) -> ndarray: ...
def sort(a: Any, *args: Any, **kwargs: Any) -> ndarray: ...
def stack(arrays: Sequence[Any], axis: int = ..., *args: Any, **kwargs: Any) -> ndarray: ...
def zeros(shape: Sequence[int] | int, dtype: Any = ..., *args: Any, **kwargs: Any) -> ndarray: ...
def array_equal(a1: Any, a2: Any, equal_nan: bool = ...) -> bool: ...
def sum(a: Any, *args: Any, **kwargs: Any) -> Any: ...


class _LinalgModule:
    def norm(self, x: Any, ord: Any = ..., axis: Any = ..., keepdims: bool = ...) -> float: ...


def atleast_2d(*arys: Any) -> ndarray: ...

def reshape(a: Any, newshape: Sequence[int] | int, *args: Any, **kwargs: Any) -> ndarray: ...


linalg: _LinalgModule
ndarray = ndarray

